load"task3.magma";

/*
 1) challenger generates a random key 
*/
function chooseKey()
return Eltseq(Random(VectorSpace(GF(2),128)));
end function;


/* First scenario:
 2-3) attacker submits a list of "numberofMessages" equal messages to the challenger
*/ 
function generateSameMessages(numberofMessages)

list :=[];
message := Eltseq (Random(VectorSpace(GF(2),128)));

for i in [1..numberofMessages] do
list := list cat message; 
end for;

return list,numberofMessages;

end function;


/* Second Scenario:
 2-3) attacker submits a list of "numberofMessages" different messages to the challenger
*/ 

function generateMessages(numberofMessages)

list :=[];

for i in [1..numberofMessages] do
message := Eltseq (Random(VectorSpace(GF(2),128)));
list := list cat message; 
end for;

return list,numberofMessages;

end function;



/* 
4) attacker flips a coin in order to decide if he has to encrypt the list of t messages 
provided by the attacker or a list of t random messages generated by him
*/
function flipCoin ()
return Eltseq(Random(VectorSpace(GF(2),1)));
end function;

/*
function to display better the list of encrypted messages provided by the challenger
*/
function displayEncryptedMessages(array)
	n := #array/128;  

	messages := [];
 
    for i in [1..n] do 
    	split_arrays := [];
     	first := (i-1) * 128 + 1;
        last := i * 128;
        split_arrays :=  split_arrays cat array[first .. last];
        print " \n EncryptedMessage", i, ":";
        string := "";
        for i in [1..128] do 
        	string := string cat IntegerToString(split_arrays[i]);
        end for;
        messages := Append(messages,string);
        print (string);
    end for;
    return messages;
end function;

/* 
5) Challenger receives the list of "numberofMessages" messages and provides to the challenger the list of encrypted messages 
(if coin = 1 he encrypts the list provided by attacker otherwise he generates a list of random messages,
and outputs the encrypted list)
*/
function ChoosenPlainTextEncryption(list,numberofMessages)
encryptedList :=[];

key := chooseKey();

coin := Integers()!flipCoin();

if coin eq 1 then 

	for i in [1..(numberofMessages*128) by 128] do 

		messageCopy := [];
		for j in [i..i+127] do 
			messageCopy := Append (messageCopy, list[j]);
		end for;
        
		encryptedList := encryptedList cat weakenedAES(messageCopy,key);
	end for;

	print("Flipped coin: ");

	print coin;

	return displayEncryptedMessages(encryptedList), coin;
end if;


randomMessages := [];

for i in [1..numberofMessages] do

message := Eltseq (Random(VectorSpace(GF(2),128)));
randomMessages := randomMessages cat message; 

end for;

randomEncryptedMessages := [];

for i in [1..(numberofMessages*128) by 128] do 

		messageCopy := [];
		for j in [i..i+127] do 
			messageCopy := Append (messageCopy, randomMessages[j]);
		end for;

		randomEncryptedMessages := randomEncryptedMessages cat weakenedAES(messageCopy,key);
	end for;

	
	print("Flipped coin: ");

	print coin;
	return displayEncryptedMessages(randomEncryptedMessages), coin;

end function;


/* 
In order to win the game with probability 1 the attacker chooses a list,composed by, at least, two same messages, and 
if the encrypted messages provided by the challenger are equals the value of the flipped coin is 1, due to the fact that
the challenger has encrypted the list of messages provided by him, otherwise the value is 0.
*/

function playGame()

numberofMessages := 2;
list,_ := generateSameMessages(numberofMessages);
encryptedMessages, b := ChoosenPlainTextEncryption(list,numberofMessages);

//attacker checks if the two encrypted messages are equals and returns b:=1 otherwise b:=0; 

AttackerB := 0;

if encryptedMessages [1] eq encryptedMessages [2] then
AttackerB := 1; 
end if;


if AttackerB eq b then
print("Attacker bets:");
return AttackerB,(" \n \nAttacker won the game") ;
end if;


print("Attacker bets:");
return AttackerB,("\n  \n Attacker didn't win the game");


end function;